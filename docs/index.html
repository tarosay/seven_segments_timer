<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>7セグ カウントダウンタイマー</title>
  <style>
    :root {
      --seg-color: #ff1a1a;
      --seg-glow: rgba(255, 26, 26, 0.35);
      --seg-off: rgba(255, 26, 26, 0.12);
      --bg-color: #050505;
      /* JSがセットする：--digit-w / --digit-h / --seg-t / --seg-gap / --colon-w / --ui-gap / --dot-size */
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: #ffffff;
      color: #111;
      display: flex;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
    }

    .wrap {
      width: 100vw;
      max-width: none;
      padding: 16px;
      box-sizing: border-box;
      display: grid;
      gap: 18px;
    }

    .panel {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 6px 22px rgba(0, 0, 0, .06);
      width: 100%;
      box-sizing: border-box;
    }

    .display-shell {
      background: var(--bg-color);
      border-radius: 10px;
      padding: 18px 18px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      width: 100%;
      box-sizing: border-box;
    }

    .display-shell.completed {
      /* 完了時（元の終了色）：セグメント色=シアン / 背景=紫 */
      --seg-color: #00e5ff;
      --seg-glow: rgba(0, 229, 255, 0.35);
      --seg-off: rgba(0, 229, 255, 0.12);
      --bg-color: #1a002e;
    }

    .display-shell.completed.alt {
      /* 点滅用（元のカウントダウン色）：セグメント色=赤 */
      --seg-color: #ff1a1a;
      --seg-glow: rgba(255, 26, 26, 0.35);
      --seg-off: rgba(255, 26, 26, 0.12);
    }

    /* 完了時に 00:00:00 を点滅させる */
    @keyframes blinkZero {

      0%,
      49% {
        opacity: 1;
      }

      50%,
      100% {
        opacity: 0;
      }
    }

    .blink {
      animation: blinkZero 0.8s steps(1, end) infinite;
    }

    @media (prefers-reduced-motion: reduce) {
      .blink {
        animation: none;
      }
    }

    .display {
      display: flex;
      align-items: center;
      gap: var(--ui-gap, 14px);
      user-select: none;
    }

    .digit {
      position: relative;
      width: var(--digit-w);
      height: var(--digit-h);
      flex: 0 0 auto;
    }

    /* セグ（形状は水平/垂直で分離） */
    .seg {
      position: absolute;
      background: var(--seg-off);
      filter: drop-shadow(0 0 0 rgba(0, 0, 0, 0));
      border-radius: 6px;
      transition: background .08s linear, filter .08s linear;

      /* 先端角90°の切り欠き */
      --cap: calc(var(--seg-t) / 2);

      --join: max(0px, calc(var(--seg-t) - var(--seg-gap)));
    }

    .seg.on {
      background: var(--seg-color);
      filter: drop-shadow(0 0 10px var(--seg-glow));
    }

    /* 水平セグ：配置 */
    .seg.a,
    .seg.g,
    .seg.d {
      height: var(--seg-t);
      left: var(--seg-gap);
      right: var(--seg-gap);
    }

    .seg.a {
      top: 0;
    }

    .seg.g {
      top: calc(50% - (var(--seg-t) / 2));
    }

    .seg.d {
      bottom: 0;
    }

    /* 垂直セグ：配置 */
    .seg.f,
    .seg.b,
    .seg.e,
    .seg.c {
      width: var(--seg-t);
      top: var(--seg-gap);
      bottom: var(--seg-gap);
    }

    /* ここで + var(--join) を足すことで、中央ギャップも変わる */
    .seg.f,
    .seg.b {
      height: calc(50% - var(--seg-gap) - (var(--seg-t) / 2) + var(--join));
      bottom: auto;
    }

    .seg.e,
    .seg.c {
      height: calc(50% - var(--seg-gap) - (var(--seg-t) / 2) + var(--join));
      top: auto;
    }

    .seg.f {
      left: 0;
    }

    .seg.b {
      right: 0;
    }

    .seg.e {
      left: 0;
    }

    .seg.c {
      right: 0;
    }

    /* 形状：水平 */
    .seg.a,
    .seg.g,
    .seg.d {
      clip-path: polygon(0% 50%,
          var(--cap) 0%,
          calc(100% - var(--cap)) 0%,
          100% 50%,
          calc(100% - var(--cap)) 100%,
          var(--cap) 100%);
    }

    /* 形状：垂直（水平を90°回転） */
    .seg.b,
    .seg.c,
    .seg.e,
    .seg.f {
      clip-path: polygon(50% 0%,
          100% var(--cap),
          100% calc(100% - var(--cap)),
          50% 100%,
          0% calc(100% - var(--cap)),
          0% var(--cap));
    }

    /* コロン */
    .colon {
      width: var(--colon-w, 20px);
      height: var(--digit-h);
      position: relative;
      flex: 0 0 auto;
    }

    .dot {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: var(--dot-size, 14px);
      height: var(--dot-size, 14px);
      border-radius: 50%;
      background: var(--seg-color);
      filter: drop-shadow(0 0 10px var(--seg-glow));
      opacity: .95;
    }

    .dot.top {
      top: calc(35% - (var(--dot-size, 14px) / 2));
    }

    .dot.bot {
      top: calc(65% - (var(--dot-size, 14px) / 2));
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    label {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="text"] {
      font-size: 16px;
      padding: 10px 12px;
      border: 1px solid #ccc;
      border-radius: 10px;
      width: min(240px, 70vw);
    }

    button {
      font-size: 16px;
      padding: 10px 14px;
      border: 1px solid #bbb;
      background: #fff;
      border-radius: 10px;
      cursor: pointer;
    }

    button:active {
      transform: translateY(1px);
    }

    button.primary {
      border-color: #666;
      font-weight: 600;
    }

    .hint {
      color: #444;
      font-size: 13px;
      margin-top: 10px;
      line-height: 1.5;
    }

    .status {
      margin-left: auto;
      font-size: 14px;
      color: #333;
      white-space: nowrap;
    }

    @media (max-width:520px) {
      :root {
        --digit-w: 64px;
        --digit-h: 116px;
        --seg-t: 12px;
        --seg-gap: 8px;
      }

      .colon {
        width: 16px;
      }

      .display {
        gap: 10px;
      }

      .status {
        width: 100%;
        margin-left: 0;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel display-shell" aria-label="7セグ表示のカウントダウンタイマー">
      <div id="display" class="display" role="img" aria-label="00:00:00"></div>
    </div>

    <div class="panel">
      <div class="controls">
        <label>
          <span>入力（h:m:s）</span>
          <input id="timeInput" type="text" value="0:10:0" inputmode="numeric" autocomplete="off" />
        </label>

        <button id="startBtn" class="primary">スタート</button>
        <button id="resetBtn">リセット</button>

        <div id="status" class="status">停止中</div>
      </div>

      <div class="hint">
        例: <code>0:10:0</code> → 表示は <code>00:10:00</code><br />
        入力変更で即表示が更新されます（動作中は一時停止してから反映）。
      </div>
    </div>
  </div>

  <script>
    // 7セグの点灯マップ（a,b,c,d,e,f,g）
    // index: 0=a,1=b,2=c,3=d,4=e,5=f,6=g
    const DIGIT_MAP = {
      "0": [1, 1, 1, 1, 1, 1, 0],
      "1": [0, 1, 1, 0, 0, 0, 0],
      "2": [1, 1, 0, 1, 1, 0, 1],
      "3": [1, 1, 1, 1, 0, 0, 1],
      "4": [0, 1, 1, 0, 0, 1, 1],
      "5": [1, 0, 1, 1, 0, 1, 1],
      "6": [1, 0, 1, 1, 1, 1, 1],
      "7": [1, 1, 1, 0, 0, 0, 0],
      "8": [1, 1, 1, 1, 1, 1, 1],
      "9": [1, 1, 1, 1, 0, 1, 1],
      " ": [0, 0, 0, 0, 0, 0, 0]
    };

    const SEG_CLASSES = ["a", "b", "c", "d", "e", "f", "g"];

    const displayEl = document.getElementById("display");
    const displayShellEl = document.querySelector(".display-shell");
    const inputEl = document.getElementById("timeInput");
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");
    const statusEl = document.getElementById("status");

    // 終了音（index.htmlと同じフォルダに end_sound.mp3 を置く）
    // ※ブラウザの自動再生制限対策：ユーザー操作（スタート押下）時に一度だけ“解錠”する
    const endSound = new Audio("end_sound.mp3");
    endSound.preload = "auto";
    let audioPrimed = false;


    // 警告音（index.htmlと同じフォルダに warn_sound.mp3 を置く）
    // 残り5秒になったらループ再生し、0秒で停止して終了音へ
    const warnSound = new Audio("warn_sound.mp3");
    warnSound.preload = "auto";
    let warnLooping = false;

    // 何秒前から警告音を鳴らし始めるか（スクリプトで変更可能）
    const WARN_START_SEC = 10;
    let warnEverStarted = false;
    let endPending = false;


    function startWarnLoop() {
      if (warnLooping) return;
      warnLooping = true;
      warnEverStarted = true;
      try {
        warnSound.pause();
        warnSound.currentTime = 0;
        warnSound.loop = true;
      } catch { /* ignore */ }
      const p = warnSound.play();
      if (p && typeof p.catch === "function") p.catch(() => { });
    }


    function startWarnOnce() {
      // WARN_START_SEC が 1 のようなケース用：ループせずに1回だけ鳴らす
      if (warnEverStarted) return;
      warnEverStarted = true;
      warnLooping = false;
      try {
        warnSound.pause();
        warnSound.currentTime = 0;
        warnSound.loop = false;
      } catch { /* ignore */ }
      const p = warnSound.play();
      if (p && typeof p.catch === "function") p.catch(() => { });
    }

    function stopWarnLoop() {
      if (!warnLooping) return;
      warnLooping = false;
      try {
        warnSound.pause();
        warnSound.currentTime = 0;
        warnSound.loop = false;
      } catch { /* ignore */ }
    }

    // warnを停止して「止まった」ことをイベントで確認してから次へ進む（完了時用）

    // warn_sound.mp3 を「頭から1回だけ」鳴らし切るのを待つ（0秒になった時の最後の1回用）
    function playWarnOneShotAndWait() {
      return new Promise((resolve) => {
        if (WARN_START_SEC <= 0) { resolve(); return; }

        let settled = false;
        const finish = () => {
          if (settled) return;
          settled = true;
          try { warnSound.removeEventListener("ended", onEnded); } catch { }
          try { warnSound.currentTime = 0; } catch { }
          setTimeout(resolve, 0);
        };
        const onEnded = () => finish();

        try {
          warnSound.pause();
          warnSound.currentTime = 0;
          warnSound.loop = false;
        } catch { /* ignore */ }

        // ended が取れない場合に備えて duration でフォールバック
        let waitMs = 1200;
        try {
          const d = warnSound.duration;
          if (Number.isFinite(d) && d > 0) waitMs = Math.ceil(d * 1000) + 80;
        } catch { /* ignore */ }

        try { warnSound.addEventListener("ended", onEnded, { once: true }); } catch { /* ignore */ }

        const p = warnSound.play();
        if (p && typeof p.catch === "function") p.catch(() => finish());

        setTimeout(finish, waitMs);
      });
    }

    function stopWarnLoopAndWait() {
      // 0到達時：warn は途中で切らない（pauseしない）。
      // ループだけ解除して、currentTime が進まなくなる＝実再生が止まったことをポーリングで確認してから次へ進む。
      return new Promise((resolve) => {
        // 以後の再スタート抑止（tickは止めているが念のため）
        warnLooping = false;
        try { warnSound.loop = false; } catch { /* ignore */ }

        let lastCt = null;
        let stableCount = 0;
        const EPS = 0.001;    // 1ms 以上進んだら「まだ鳴っている」
        const NEED_STABLE = 20; // 20回連続（約600ms）止まっていれば「鳴りやんだ」とみなす

        const poll = () => {
          let ct = 0;
          try { ct = warnSound.currentTime; } catch { /* ignore */ }

          if (lastCt === null) {
            lastCt = ct;
            setTimeout(poll, 30);
            return;
          }

          if (ct > lastCt + EPS) {
            // まだ進んでいる＝鳴っている
            lastCt = ct;
            stableCount = 0;
            setTimeout(poll, 30);
            return;
          }

          // 進んでいない
          lastCt = ct;
          stableCount += 1;
          if (stableCount >= NEED_STABLE) {
            resolve();
            return;
          }
          setTimeout(poll, 30);
        };

        poll();
      });
    }


    function primeAudioOnce() {
      if (audioPrimed) return;
      audioPrimed = true;

      // ユーザー操作直後なら再生が許可されやすい。短く再生→停止で“解錠”を試みる。
      // 重要: 本番で使う endSound / warnSound を直接 pause() すると、
      //       直後に開始した再生を止めてしまう競合が起きるため、ここでは別インスタンスでプリムする。
      try {
        const tmpEnd = new Audio(endSound.src);
        tmpEnd.volume = 1.0;
        tmpEnd.loop = false;
        const p = tmpEnd.play();
        if (p && typeof p.then === "function") {
          p.then(() => {
            tmpEnd.pause();
            tmpEnd.currentTime = 0;
          }).catch(() => { });
        }
      } catch { /* ignore */ }

      try {
        const tmpWarn = new Audio(warnSound.src);
        tmpWarn.volume = 1.0;
        tmpWarn.loop = false;
        const pw = tmpWarn.play();
        if (pw && typeof pw.then === "function") {
          pw.then(() => {
            tmpWarn.pause();
            tmpWarn.currentTime = 0;
          }).catch(() => { });
        }
      } catch { /* ignore */ }
    }

    function startEndAlert() {
      try {
        endSound.pause();
        endSound.currentTime = 0;
        endSound.loop = true; // 点滅中はループ再生
      } catch { /* ignore */ }
      const p = endSound.play();
      if (p && typeof p.catch === "function") p.catch(() => { });
    }

    function stopEndAlert() {
      try {
        endSound.pause();
        endSound.currentTime = 0;
        endSound.loop = false;
      } catch { /* ignore */ }
    }

    // 表示要素（HH:MM:SS → 6桁 + コロン2つ）
    const digitEls = []; // 6 digits
    function buildDisplay() {
      displayEl.innerHTML = "";

      function makeDigit() {
        const d = document.createElement("div");
        d.className = "digit";
        const segs = [];
        for (const c of SEG_CLASSES) {
          const s = document.createElement("div");
          s.className = `seg ${c}`;
          d.appendChild(s);
          segs.push(s);
        }
        d._segs = segs;
        return d;
      }

      function makeColon() {
        const c = document.createElement("div");
        c.className = "colon";
        const t = document.createElement("div");
        t.className = "dot top";
        const b = document.createElement("div");
        b.className = "dot bot";
        c.appendChild(t);
        c.appendChild(b);
        return c;
      }

      // HH
      digitEls.push(makeDigit(), makeDigit());
      displayEl.appendChild(digitEls[0]);
      displayEl.appendChild(digitEls[1]);
      displayEl.appendChild(makeColon());

      // MM
      digitEls.push(makeDigit(), makeDigit());
      displayEl.appendChild(digitEls[2]);
      displayEl.appendChild(digitEls[3]);
      displayEl.appendChild(makeColon());

      // SS
      digitEls.push(makeDigit(), makeDigit());
      displayEl.appendChild(digitEls[4]);
      displayEl.appendChild(digitEls[5]);
    }

    function setDigit(digitEl, ch) {
      const map = DIGIT_MAP[ch] ?? DIGIT_MAP[" "];
      for (let i = 0; i < 7; i++) {
        digitEl._segs[i].classList.toggle("on", !!map[i]);
      }
    }

    function pad2(n) { return String(n).padStart(2, "0"); }

    let colorBlinkId = null;
    let colorBlinkState = false;

    function startColorBlink() {
      if (colorBlinkId !== null) return;
      colorBlinkState = false;
      displayShellEl.classList.remove("alt");
      // 0.5秒ごとに 赤⇄青 を切り替え
      colorBlinkId = setInterval(() => {
        colorBlinkState = !colorBlinkState;
        displayShellEl.classList.toggle("alt", colorBlinkState);
      }, 500);
    }

    function stopColorBlink() {
      if (colorBlinkId !== null) {
        clearInterval(colorBlinkId);
        colorBlinkId = null;
      }
      displayShellEl.classList.remove("alt");
    }

    function setCompleted(isCompleted) {
      displayShellEl.classList.toggle("completed", isCompleted);
      if (isCompleted) {
        startColorBlink();
        startEndAlert();
      } else {
        stopColorBlink();
        stopEndAlert();
      }
    }

    function formatHMS(totalMs) {
      const totalSec = Math.max(0, Math.ceil(totalMs / 1000)); // 表示は切り上げで「残り」を分かりやすく
      const h = Math.floor(totalSec / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
    }

    function render(textHMS) {
      // textHMS: "HH:MM:SS"
      const parts = textHMS.split(":");
      const hh = parts[0] ?? "00";
      const mm = parts[1] ?? "00";
      const ss = parts[2] ?? "00";
      const six = (hh + mm + ss).padEnd(6, "0").slice(0, 6);

      for (let i = 0; i < 6; i++) {
        setDigit(digitEls[i], six[i]);
      }
      displayEl.setAttribute("aria-label", textHMS);
    }

    function parseInputToMs(str) {
      // 期待: h:m:s（各フィールドは整数、空欄は0扱い）
      // 例: "0:1:0" -> 60秒
      const raw = String(str ?? "").trim();
      if (!raw) return 0;

      const items = raw.split(":").map(s => s.trim());
      if (items.length < 1 || items.length > 3) return 0;

      let h = 0, m = 0, s = 0;
      if (items.length === 1) {
        // "ss" のみも許容（不要なら消してOK）
        s = Number(items[0]);
      } else if (items.length === 2) {
        // "m:s"
        m = Number(items[0]);
        s = Number(items[1]);
      } else {
        h = Number(items[0]);
        m = Number(items[1]);
        s = Number(items[2]);
      }

      if (![h, m, s].every(v => Number.isFinite(v) && v >= 0)) return 0;

      h = Math.floor(h); m = Math.floor(m); s = Math.floor(s);
      return ((h * 3600 + m * 60 + s) * 1000);
    }

    // タイマー状態
    let running = false;
    let remainingMs = 0;
    let endAt = 0;
    let tickId = null;

    function stop() {
      running = false;
      endPending = false;
      stopWarnLoop();
      if (tickId !== null) {
        clearInterval(tickId);
        tickId = null;
      }
      startBtn.textContent = "スタート";
      statusEl.textContent = "停止中";
      setCompleted(false);
    }

    function start() {
      setCompleted(false);
      if (remainingMs <= 0) {
        // 新規開始（入力値から開始）：warn 状態も初期化
        warnEverStarted = false;
        warnLooping = false;
        try {
          warnSound.pause();
          warnSound.currentTime = 0;
          warnSound.loop = false;
        } catch { /* ignore */ }

        remainingMs = parseInputToMs(inputEl.value);
      }
      if (remainingMs <= 0) {
        render("00:00:00");
        return;
      }

      running = true;
      startBtn.textContent = "一時停止";
      statusEl.textContent = "動作中";
      endAt = performance.now() + remainingMs;

      // スタート直後に既に WARN_START_SEC 秒以内なら、ここで即 warn を開始（初回スタートで鳴らない問題対策）
      const initDispSec = Math.ceil(remainingMs / 1000);
      if (initDispSec <= WARN_START_SEC && initDispSec > 0) {
        startWarnLoop();
      } else {
        stopWarnLoop();
      }


      // 100ms程度で十分滑らか＆軽量
      tickId = setInterval(() => {
        const now = performance.now();
        remainingMs = endAt - now;

        if (remainingMs <= 0) {
          remainingMs = 0;
          render("00:00:00");

          // ここは「停止」ではなく「完了」扱いにする（stop()はsetCompleted(false)してしまうため使わない）
          if (endPending) return;
          endPending = true;

          running = false;
          if (tickId !== null) {
            clearInterval(tickId);
            tickId = null;
          }
          startBtn.textContent = "スタート";
          statusEl.textContent = "完了";

          // warnが確実に鳴りやんでから終了音へ
          (async () => {
            // 0到達時：warn は「途中で切らない」。
            // ループだけ解除して、今鳴っている1回分が自然終了（ended）したのを確認してから end を鳴らす。
            await stopWarnLoopAndWait();
            setCompleted(true); // ここで end_sound.mp3 が鳴る
          })(); return;
        }
        // 残りWARN_START_SEC秒になったら警告音をループ再生（途中でリセットしない＝ぶつ切れ防止）
        const dispSec = Math.ceil(remainingMs / 1000);

        // warn を「ループさせるのは 1 まで」：
        //  - WARN_START_SEC .. 2 の間は loop 再生
        //  - 1 になったら loop を解除（pauseしない）
        //  - 0 になったら warn の停止（currentTime停止）を確認してから end を鳴らす
        if (dispSec <= WARN_START_SEC && dispSec > 1) {
          startWarnLoop();
        } else if (dispSec === 1 && dispSec <= WARN_START_SEC) {
          // 最後の1秒：新規開始の場合は1回だけ、既に鳴っている場合はループ解除
          if (!warnEverStarted) {
            startWarnOnce();
          } else {
            try { warnSound.loop = false; } catch { /* ignore */ }
            warnLooping = false;
          }
        } else {
          stopWarnLoop();
        }

        render(formatHMS(remainingMs));
      }, 100);
    }

    function applyInputToDisplay() {
      remainingMs = parseInputToMs(inputEl.value);
      render(formatHMS(remainingMs));
      setCompleted(false);
      statusEl.textContent = "停止中";

      // 新規設定時は warn の状態も初期化
      warnEverStarted = false;
      warnLooping = false;
      try {
        warnSound.pause();
        warnSound.currentTime = 0;
        warnSound.loop = false;
      } catch { /* ignore */ }
    }

    // 初期化
    buildDisplay();
    fitToWidth();
    applyInputToDisplay();


    // 入力変更で即表示（動作中は誤動作防止で停止）
    inputEl.addEventListener("input", () => {
      if (running) stop();
      applyInputToDisplay();
    });

    startBtn.addEventListener("click", () => {
      // ブラウザの自動再生制限対策：ユーザー操作の瞬間に音を“解錠”
      primeAudioOnce();

      if (!running) {
        // 停止中は「続き」から再開する（remainingMs を上書きしない）
        // ただし remainingMs が 0 以下（未設定/完了）なら入力値から開始
        if (remainingMs <= 0) {
          remainingMs = parseInputToMs(inputEl.value);
        }
        render(formatHMS(remainingMs)); // 表示を整形
        start();
      } else {
        // 一時停止（remainingMs は tick 側で更新済み）
        stop();
        render(formatHMS(remainingMs));
      }
    });

    resetBtn.addEventListener("click", () => {
      stop();
      applyInputToDisplay();
    });

    function fitToWidth() {
      const shell = document.querySelector(".display-shell");
      const avail = shell.getBoundingClientRect().width - 36; // padding分の見込み

      if (avail <= 0) return;

      // ここから下は既存の計算ロジック（Wを求めてCSS変数にsetPropertyする部分）
      const colonRatio = 0.24;
      const gapRatio = 0.14;

      const W = avail / (6 + 2 * colonRatio + 7 * gapRatio);
      const H = W * (148 / 84);

      const segT = Math.max(8, W * 0.17);
      const segGp = Math.max(6, W * 0.11);

      document.documentElement.style.setProperty("--digit-w", `${W}px`);
      document.documentElement.style.setProperty("--digit-h", `${H}px`);
      document.documentElement.style.setProperty("--seg-t", `${segT}px`);
      document.documentElement.style.setProperty("--seg-gap", `${segGp}px`);
      document.documentElement.style.setProperty("--colon-w", `${W * colonRatio}px`);
      document.documentElement.style.setProperty("--ui-gap", `${W * gapRatio}px`);
      document.documentElement.style.setProperty("--dot-size", `${Math.max(10, W * 0.18)}px`);
    }



    // 起動時とリサイズ時にフィット
    window.addEventListener("resize", () => {
      fitToWidth();
      render(formatHMS(remainingMs));
    });

  </script>
</body>

</html>